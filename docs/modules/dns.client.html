<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>DNS</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>dns.lua</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><strong>dns.client</strong></li>
  <li><a href="../modules/dns.utils.html">dns.utils</a></li>
</ul>
<h2>Topics</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../topics/readme.md.html">readme</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>dns.client</code></h1>
<p>DNS client.</p>
<p> Works with OpenResty only. Requires the <code>resty.dns.resolver</code> module.</p>

<p> <em>NOTES</em>: </p>

<ol>
    <li>parsing the config files upon initialization uses blocking i/o, so use with
    care. See <code>init()</code> for details.</li>
    <li>All returned records are directly from the cache. So do not modify them! If you
    need to, copy them first.</li>
    <li>TTL for records is the TTL returned by the server at the time of fetching
    and won't be updated while the client serves the records from its cache.</li>
    <li>resolving IPv4 (A-type) and IPv6 (AAAA-type) addresses is explicitly supported. If
    the hostname to be resolved is a valid IP address, it will be cached with a ttl of
    10 years. So the user doesn't have to check for ip adresses.</li>
</ol>

<p> See <code>./examples/</code> for examples and output returned.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2016 Mashape Inc.</li>
        <li><strong>License</strong>: Apache 2.0</li>
        <li><strong>Author</strong>: Thijs Schreijer</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#connect">connect (sock, host, port, opts)</a></td>
	<td class="summary">Implements tcp-connect method with dns resolution.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#init">init (options)</a></td>
	<td class="summary">initialize resolver.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#purge_cache">purge_cache (touched)</a></td>
	<td class="summary">Cleanup the DNS client cache.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#resolve">resolve (qname, r_opts, dns_cache_only, r)</a></td>
	<td class="summary">Resolve a name.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#stdError">stdError ()</a></td>
	<td class="summary">Standardizes the <a href="../modules/dns.client.html#resolve">resolve</a> output to more standard Lua errors.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#toip">toip (qname, port, dns_cache_only, r)</a></td>
	<td class="summary">Resolves to an IP and port number.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "connect"></a>
    <strong>connect (sock, host, port, opts)</strong>
    </dt>
    <dd>
    Implements tcp-connect method with dns resolution.
 This builds on top of <a href="../modules/dns.client.html#toip">toip</a>. If the name resolves to an SRV record,
 the port returned by the DNS server will override the one provided.
 <strong>NOTE</strong>: can also be used for other connect methods; http/redis as long as
 the argument order is the same


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">sock</span>
         the socket to connect
        </li>
        <li><span class="parameter">host</span>
         hostname to connect to
        </li>
        <li><span class="parameter">port</span>
         port to connect to
        </li>
        <li><span class="parameter">opts</span>
         the options table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        success, or nil + error
    </ol>




</dd>
    <dt>
    <a name = "init"></a>
    <strong>init (options)</strong>
    </dt>
    <dd>
    initialize resolver.  When called multiple times, it will clear the cache.
 Will parse hosts and resolv.conf files/tables.
 If the <code>hosts</code> and <code>resolv_conf</code> fields are not provided, it will fall back on default
 filenames (see the <a href="../modules/dns.utils.html#">dns.utils</a> module for details). To prevent any potential
 blocking i/o all together, manually fetch the contents of those files and
 provide them as tables. Or provide both fields as empty tables.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">options</span>
         Same table as the openresty dns resolver, with extra fields <code>hosts</code>, <code>resolv_conf</code> containing the filenames to parse.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true on success, nil+error otherwise
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="comment">-- initialize without any blocking i/o
</span> <span class="keyword">local</span> client = <span class="global">require</span>(<span class="string">"dns.client"</span>)
 <span class="global">assert</span>(client.init({
          hosts = {},
          resolv_conf = {},
        })
 )</pre>
    </ul>

</dd>
    <dt>
    <a name = "purge_cache"></a>
    <strong>purge_cache (touched)</strong>
    </dt>
    <dd>
    Cleanup the DNS client cache.  Items will be checked on TTL only upon
 retrieval from the cache. So items inserted, but never used again will
 never be removed from the cache automatically. So unless you have a very
 restricted fixed set of hostnames you're resolving, you should occasionally
 purge the cache.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">touched</span>
         in seconds. Cleanup everything (also non-expired items) not touched in <code>touched</code> seconds. If omitted, only expired items (based on ttl) will be removed.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        number of entries deleted
    </ol>




</dd>
    <dt>
    <a name = "resolve"></a>
    <strong>resolve (qname, r_opts, dns_cache_only, r)</strong>
    </dt>
    <dd>
    Resolve a name. <br/>
 If <code>r_opts.qtype</code> is given, then it will fetch that specific type only (if it's a <code>TYPE_CNAME</code> then
 it will return the cname record). If <code>r_opts.qtype</code> is not provided, then it will try to resolve
 the name using the following record types, in the order listed;</p>

<ol>
    <li>last succesful lookup type (if any), </li>
    <li>A-record, </li>
    <li>AAAA-record, </li>
    <li>SRV-record,  --> will be returned, if found, will not be dereferenced</li>
    <li>CNAME-record --> will not be returned, but dereferenced, so its target will be returned</li>
</ol>

<p> So requesting <code>mysrv.domain.com</code> (assuming to be an SRV record) will try to resolve
 it (the first time) as A, then AAAA, then SRV, CNAME will not be tried. If succesful, a second lookup
 will now try SRV, A, AAAA, CNAME.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">qname</span>
         Name to resolve
        </li>
        <li><span class="parameter">r_opts</span>
         Options table, see remark about the <code>qtype</code> field above
        </li>
        <li><span class="parameter">dns_cache_only</span>
         Only check the cache, won't do server lookups (will not invalidate any ttl expired data and will possibly return expired data)
        </li>
        <li><span class="parameter">r</span>
         (optional) dns resolver object to use
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <code>list of records + nil + r</code>, or <code>nil + err + r</code>. The list can be empty if the name is present on the server, but has a different record type. Any dns server errors are returned in a hashtable (see openresty docs).
    </ol>




</dd>
    <dt>
    <a name = "stdError"></a>
    <strong>stdError ()</strong>
    </dt>
    <dd>
    Standardizes the <a href="../modules/dns.client.html#resolve">resolve</a> output to more standard Lua errors.
 Both <code>nil+error+r</code> and succesful lookups are passed through.
 A server error table is returned as <code>nil+error+r</code> (where <code>error</code> is a string extracted from the server error table).
 An empty response is returned as <code>response+error+r</code> (where <code>error</code> is 'dns query returned no results').



    <h3>Returns:</h3>
    <ol>

        a valid (non-empty) query result + nil + r, or nil + error + r
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">
 <span class="keyword">local</span> result, err, r = client.stdError(client.resolve(<span class="string">"my.hostname.com"</span>))

 <span class="keyword">if</span> err <span class="keyword">then</span> error(err) <span class="keyword">end</span>         <span class="comment">--&gt; only passes if there is at least 1 result returned
</span> <span class="keyword">if</span> <span class="keyword">not</span> result <span class="keyword">then</span> error(err) <span class="keyword">end</span>  --&gt; does <span class="keyword">not</span> error on an empty result <span class="global">table</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "toip"></a>
    <strong>toip (qname, port, dns_cache_only, r)</strong>
    </dt>
    <dd>
    Resolves to an IP and port number.
 Does a round-robin over the returned records. Builds on top of <a href="../modules/dns.client.html#resolve">resolve</a>, but will also further
 dereference SRV type records. Will round-robin on each level individually. Eg.
 SRV with 2 entries; a) IPv4 address, b) hostname to an A record with also 2 entries, b1 and b2.
 Calling <a href="../modules/dns.client.html#toip">toip</a> 4 times will in turn result in; 1) a, 2) b1, 3) a, 4) b2.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">qname</span>
         hostname to resolve
        </li>
        <li><span class="parameter">port</span>
         (optional) default port number to return if none was found in the lookup chain
        </li>
        <li><span class="parameter">dns_cache_only</span>
         (optional) if truthy, no dns queries will be performed, only cache lookups
        </li>
        <li><span class="parameter">r</span>
         (optional) dns resolver object to use
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <code>ip address + port + r</code>, or <code>nil + error + r</code>
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2016-10-10 17:16:30 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
